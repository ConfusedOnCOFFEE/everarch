* segfault in evr-glacier-storage's evr_free_glacier_read_ctx :bug:
#+BEGIN_SRC
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00005645153fbbac in evr_free_glacier_read_ctx (ctx=0x15500) at glacier.c:103
103	    if(sqlite3_finalize(ctx->list_blobs_stmt_order_blob_ref) != SQLITE_OK){
[Current thread is 1 (Thread 0x7f8272ffd700 (LWP 3537887))]
(gdb) bt
#0  0x00005645153fbbac in evr_free_glacier_read_ctx (ctx=0x15500) at glacier.c:103
#1  0x00005645153fa7a6 in evr_connection_worker (context=<optimized out>) at evr-glacier-storage.c:423
#2  0x00007f828bba3f5a in start_thread (arg=<optimized out>) at pthread_create.c:474
#3  0x00007f828bad3def in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
#+END_SRC

the segfault happend when connecting to the glacier server using a
python api and immediately closing the socket again.
* evr-attr-index should ignore invalid attr-index specs
right now the indexer stops if an invalid attr-index spec is
discovered:

#+BEGIN_SRC
Jun 02 10:08:01 pc60684 evr-attr-index[1465214]: 2022-06-02T10:08:01 iE Failed to parse XSLT stylesheet from blob with ref sha3-224-2540e45925ae64439eceab1ef41a161274db5f6bca8ff08aea58d1e6
Jun 02 10:08:01 pc60684 evr-attr-index[1465214]: 2022-06-02T10:08:01 iE Failed building attr index for sha3-224-82c4e4de95cf92b2cfcdea0f72dcc0c6ec5fbcba1feae3f27d8836fa
Jun 02 10:08:01 pc60684 evr-attr-index[1465214]: 2022-06-02T10:08:01 iD Ended build index worker with result 1
#+END_SRC

it should ignore and log the broken index spec.
* evr get commands must validate retrieved hashes
the commands evr get and evr get-file must validate if the calculated
hash matches the claim ref for each retrieved blob. evr must fail with
an error code unequal 0 if the hashes don't match.
* evr-attr-index must fail if it can't connect to evr-glacier-storage
right now evr-attr-index keeps running if it can't connect to a
evr-glacier-storage server. there is also no retry or something.

#+BEGIN_SRC
$ evr-attr-index
2022-05-31T20:46:45 iD Parsing config file /home/marook/.config/everarch/attr-index.conf
2022-05-31T20:46:45 iD Started watch index claims worker
2022-05-31T20:46:45 iD Use SSL cert /home/marook/.local/etc/everarch/glacier-cert.pem for localhost:2361
2022-05-31T20:46:45 iD Started build index worker
2022-05-31T20:46:45 iD Started index sync worker
2022-05-31T20:46:45 iI Listening on localhost:2362
2022-05-31T20:46:45 iE Unable to connect to localhost:2361
2022-05-31T20:46:45 iE Failed to connect to evr-glacier-storage server
2022-05-31T20:46:45 iD Ended watch index claims worker with result 1
#+END_SRC

for now evr-attr-index must fail if the watchers can't connect. that
should make the service more stable in combination with systemd's
automatic restarts.
* create tasks for make creating claims simple in emacs
right now one would have to write a claim-set XML document and post it
manually via the shell.
* supply custom error logger to xmlSetGenericErrorFunc
libxml uses it's own error reporting right now which prints to stderr.

it should be overwritten with by calling xmlSetGenericErrorFunc(…)
with a custom error function which uses log_error to log errors.
* check glacier index.db and bucket file consistency on startup
the end pointer (which is the first 4 bytes of each bucket) of the
last written bucket should be stored in the index.db. also on startup
of evr-glacier-storage the end pointer from the last bucket and the
end pointer stored in the index.db should be
compared. evr-glacier-storage should panic if the end pointers don't
match.

this change should allow us to disable synchronization of the sqlite
index.db just like it is already done for the attr-index sqlite db.
* add evr-glacier-storage index.db recovery
evr-glacier-storage should check if the index.db and the first bucket
exist on startup. if the first bucket exists but the index.db does not
it should recreate the index.db by scanning through all existing
buckets.

drop fsyncs when writing index.db also with this change.
* parallel evr-attr-index claim-set preparation
indexing a claim-set can be splitted into two phases. a first phase
which fetches the claim-set XML, then applies the attr factories and
XSLT stylesheet on it. then a second phase which persists the attr and
archive claims into the index.

the first phase should be executed in parallel.

the solution might involve a ring buffer which n slots. each slot
holds one to be prepared claim-set. the slots in the ring buffer have
the states queued and prepared. there are n threads which fetch the
next queued slot and prepare it.
* add i18n support in attr query contains operator
right now sqlite is used for comparing values when using the attr
query contains (~) operator in a case insensitive way. the lower case
operation works only on ASCII characters. in order to get utf-8 lower
case conversion support the [[https://github.com/sqlite/sqlite/tree/master/ext/icu][sqlite ICU extension]] must be loaded.

test if this extension is part of the sqlite3 debian packaging. load
it gracefully. log info if it can't be loaded and continue.
* add claim-ref type in attr-spec's attr-def
add a new type which tells the attr-index to expect a reference to a
claim as value. attr-index should check if the value is parseable
using evr_parse_claim_ref(…).
* make attr-index host and port configurabel in evr.el
right now it's hard coded in two places. first where the connection is
opened. second where the auth token is looked up.
* auto generate ssl cert and key if they don't exists
use something like:
#+BEGIN_SRC
openssl req -newkey rsa:4096 -x509 -sha512 -nodes -out attr-index-cert.pem -keyout attr-index-key.pem
#+END_SRC
* add documentation on how to write attr-specs
** describe how attr is the central claim
** describe archive claim
** describe the seed and index-seed attributes
seed is provided before attr-factory calls and before each
transformation.

index-seed must be provided by transformation.
** describe how seed and index-seed must be handled in transformations
* reserve keywords in attr-query language
right now there are some keywords in attr-query language like for
example 'ref'. think about future keywords and reserve them so nobody
must rewrite queries in the future.
* ---- v0.1 boundary ----
everything above will be part of the first release of everarch. first
release means i will personally use it in production as mirror of my
perkeep stuff.
* add has key operator to attr query language
extend the attr query language to support searching for claims which
have a certain key.

not sure yet about the syntax:
#+BEGIN_SRC
tag=todo && some-key
tag=todo && some-key=*
#+END_SRC
* add not operator to attr query language
#+BEGIN_SRC
!tag=nsfw
!(tag=B || tag=C)
#+END_SRC

mapping the first example to sql would be quite easy because we could
do "c.seed not in (…)". but how to map the braces part i'm not sure
yet.
* sort attr-query results by last modified timestamp
right now found claims are sorted by their creation date desc. further
sort orders should be able to be specified using a order by query
expression.

examples:
#+BEGIN_SRC
tag=todo order by last-modified
tag=todo order by last-modified desc
tag=todo order by last-modified asc
tag=todo order by created
tag=todo order by created desc
tag=todo order by created asc
#+END_SRC
* sort attr-query results by a certain attr key
right now found claims are sortable by their creation and last
modification date. with this task sorting by a certain attr should be
possible.

examples:
#+BEGIN_SRC
tag=todo order by title
tag=todo order by title desc
tag=todo order by title asc
#+END_SRC
* add match functions to attr query language
#+BEGIN_SRC
tag=todo && is_image(mime_type)
#+END_SRC

the open question is how to define what the match functions are
actually doing. for example which mime types are treated as
image. this should not be coded into everarch. it would be nice to be
able to define them somehow in blobs.
* report ref and some attributes specified by key in attr querries
the query might be something like: select title where tag=todo
* make boolean and operator '&&' optional in attr query language
#+BEGIN_SRC
(tag=todo || tag=backlog) tag=howto
#+END_SRC
* gracefully handle sqlite database is locked in evr-glacier-storage
sqlite's step function will exit with SQLITE_LOCKED if a table is
locked for more than 1sec (configured right now).

a SQLITE_LOCKED error should be indicated as 'resource temporary not
available' to the client.
* evr-glacier-storage should notify systemd when ready
the systemd service type notify uses a notification approach provided
by libsystemd-daemon.so so the service can tell systemd it's
ready. this notifications should be performed after
evr-glacier-storage is listening on the socket for incomming
connections.

the configure.ac scripts should detect if systemd support is
available. maybe it the libsystemd-daemos.so or something is
present. if it is not found evr-glacier-storage must be compiled
without any systemd dependency.
* add quic support
in order to get faster connection building and encryption.

the most interesting quic library to use right now would be [[https://github.com/microsoft/msquic][msquic]]
because it depends just on OpenSSL. OpenSSL with downstream patches
unfortunately. there are [[https://www.openssl.org/blog/blog/2021/12/03/starting-the-quic-design/][plans by the OpenSSL team]] to add quic
support.
* replace struct chunk_set with linked list
dny-mem.h should provide one growable random access data structure and
one growable linked list data structure. the growable linked list data
structure is implemented in struct evr_llbuf.

especially struct dynamic_array is not very well fitted for growing
because of the evr_chunk_set_max_chunks limitation.

struct dynamic_array should be renamed to hint the random access
usage. maybe rabuf instead of dynamic_array and llbuf for chunk_set.

pitrp also suggests to copy the XARRAY or X_ARRAY implementation from
the linux kernel.

linked list chunk sizes maybe should be aligned with RLIMIT_FSIZE. see
[[elisp:(manual-entry "setrlimit(2)")][setrlimit(2)]] for retrieving RLIMIT_FSIZE and limit the chunk size
regarding to it. also the chunk size should not grow over 1MB.

there should also be a function for writing linked lists to a file
descriptor using writev.

** TODO struct evr_auth_token_cfg should use the linked list
** TODO struct evr_cert_cfg should use the linked list
* use writev instead of buf copying
writev can write mutliple buffers in one system call. this may reduce
the amout of memory being copied before a write call. there are
probably some places in glacier.c and the networking code which can
benefit from writev.
* introduce scripted transformations
attr specs should also support scripts which perform the claim
transformations instead of just xslt stylesheets.

a new transformation could look like this:

#+BEGIN_SRC xml
<attr-spec>
  <attr-def k="tag" type="str"/>
  <transformation type="bin" blob="sha3-224-00000000000000000000000000000000000000000000000000000000"/>
</attr-spec>
#+END_SRC

the transformation would point to an executable elf binary, shell or
python script.
* allow attr query args in quotes
#+BEGIN_SRC
'the key'='the value'
"the key"="the value"
#+END_SRC
* get rid of double _ in defines
as they are not intended for userspace. mentioned by pitrp.
* analyze and maybe replace own queues with lib io_uring
inter thread communitcation queues have been implemented in struct
evr_work_watch_ctx and struct evr_persister_ctx.

for the sake of using well tested code we should check migrating our
own queues to lib io_uring. mentioned by pitrp.
* implement an evr-glacier-storage blob put/get benchmark
should connect via network socket. send lots of blobs. request lots of
blobs. count blobs per second. maybe different blob sizes etc.
* create bucket directory if not existing :bdircre:
* repair out of sync bucket end pointer and file end offset :beprep:
the whole bucket should be scanned with validation of each key and
blob. if the file probably ends with one corrupt blob it should be
discarded.

it's important to be sensible about the discarded data at the end of
the file. maybe there should be an 'autorepair' flag in the
configuration.
