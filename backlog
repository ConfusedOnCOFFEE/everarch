* report further claim attributes for found refs
there should be at least these response modes:
** report only ref
** report ref and some attributes specified by key
** report ref and all attributes
* introduce content sourced attritutes
attr specs should contain declarations for content sourced
attributes. content sourced attributes are scripts which are executed
with every claim and can produce an attr claim as output.

the attr spec for content based attributes might look like this:

#+BEGIN_SRC xml
<attr-spec>
  <attr-def k="tag" type="str"/>
  <transformation type="xslt" blob="sha3-224-00000000000000000000000000000000000000000000000000000000"/>
  <attr-factory type="bin" blob="sha3-224-00000000000000000000000000000000000000000000000000000001"/>
</attr-spec>
#+END_SRC

the attr-factory must point to an executable. for example an elf
binary, shell or python script.
* add lisp output mode to evr-attr-index search results
* add emacs integration with evr-search-claim function
function evr-search-claim should search for claims with a given
expression.
* implement t in attr queries
tag=todo t=12345
tag=todo t=1970-01-01T00:00:07Z
* implement offset and limit in attr queries
tag=todo offset=0 limit=100
* add ref key to attr query language to match ref
introduce ref as keyword to match the ref of a claim. later "ref" (in
double quotes) should mean the attribute with the key ref.
* add boolean or operator to attr query language
#+BEGIN_SRC
(tag=todo || tag=backlog) && tag=howto
#+END_SRC
* add braces to attr query language
#+BEGIN_SRC
(tag=todo || tag=backlog) && tag=howto
#+END_SRC
* add not operator to attr query language
#+BEGIN_SRC
!tag=nsfw
#+END_SRC
* make evr-glacier-storage port configurable
* make evr-attr-index port configurable
* store flags and blob size redundant in buckets
right now flags and blob size in the evr-glacier-storage are storend
once for every blob and without any checksum.

there should be either a checksum for the two fields or it should be
stored redundant. this should reduce the risk of breaking a whole
bucket if one blob in it has a bit error.
* migrate tcp sockets to quic
in order to get faster connection building and encryption.
* add authentication
think of some kind of authentication for the network sockets and
implement it.
* make accepted gpg keys for verfification configurable
right now the blob signature verification accepts all valid gpg
keys. we only want to accept certain gpg keys which are probably our
own.

also the gpg public keys should be stored in the storage as
blobs. that way they should never be lost. the configuration should
reference the gpg keys sha3-224 hashes.
* ---- v0.1 boundary ----
everything above will be part of the first release of everarch. first
release means i will personally use it in production as mirror of my
perkeep stuff.
* add match functions to attr query language
#+BEGIN_SRC
tag=todo && is_image(mime_type)
#+END_SRC
* make boolean and operator '&&' optional in attr query language
#+BEGIN_SRC
(tag=todo || tag=backlog) tag=howto
#+END_SRC
* gracefully handle sqlite database is locked in evr-glacier-storage
sqlite's step function will exit with SQLITE_LOCKED if a table is
locked for more than 1sec (configured right now).

a SQLITE_LOCKED error should be indicated as 'resource temporary not
available' to the client.
* gracefully handle sqlite database is locked in evr-attr-index
sqlite's step function will exit with SQLITE_LOCKED if a table is
locked for more than 1sec (configured right now).

a SQLITE_LOCKED error should be indicated as 'resource temporary not
available' to the client.
* replace struct chunk_set with linked list
dny-mem.h should provide one growable random access data structure and
one growable linked list data structure.

especially struct dynamic_array is not very well fitted for growing
because of the evr_chunk_set_max_chunks limitation.

struct dynamic_array should be renamed to hint the random access
usage. maybe rabuf instead of dynamic_array and llbuf for chunk_set.

linked list chunk sizes maybe should be aligned with RLIMIT_FSIZE. see
[[elisp:(manual-entry "setrlimit(2)")][setrlimit(2)]] for retrieving RLIMIT_FSIZE and limit the chunk size
regarding to it. also the chunk size should not grow over 1MB.

there should also be a function for writing linked lists to a file
descriptor using writev.
* use writev instead of buf copying
writev can write mutliple buffers in one system call. this may reduce
the amout of memory being copied before a write call. there are
probably some places in glacier.c and the networking code which can
benefit from writev.
* introduce scripted transformations
attr specs should also support scripts which perform the claim
transformations instead of just xslt stylesheets.

a new transformation could look like this:

#+BEGIN_SRC xml
<attr-spec>
  <attr-def k="tag" type="str"/>
  <transformation type="bin" blob="sha3-224-00000000000000000000000000000000000000000000000000000000"/>
</attr-spec>
#+END_SRC

the transformation would point to an executable elf binary, shell or
python script.
* allow attr query args in quotes
#+BEGIN_SRC
'the key'='the value'
"the key"="the value"
#+END_SRC
* analyze and maybe replace own queues with lib io_uring
inter thread communitcation queues have been implemented in struct
evr_work_watch_ctx and struct evr_persister_ctx.

for the sake of using well tested code we should check migrating our
own queues to lib io_uring. mentioned by pitrp.
* implement an evr-glacier-storage blob put/get benchmark
should connect via network socket. send lots of blobs. request lots of
blobs. count blobs per second. maybe different blob sizes etc.
* create bucket directory if not existing :bdircre:
* repair out of sync bucket end pointer and file end offset :beprep:
the whole bucket should be scanned with validation of each key and
blob. if the file probably ends with one corrupt blob it should be
discarded.

it's important to be sensible about the discarded data at the end of
the file. maybe there should be an 'autorepair' flag in the
configuration.
