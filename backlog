* show empty window when running evr-attr-ui
application should quit when window is closed
* add attr-ui-spec command line argument to evr-attr-ui
the argument must have the prefix xslt:blob: followed by a blob
ref. evr-attr-ui must download the blob ref and parse it as xml.
* xslt transform attr-ui-spec into gtk interface xml
transformation should produce a single hello world label
initially. the produced interface xml should be parsend and replace
the code which shows the initial demo window. the xslt transformation
is part of the evr source and should be placed somewhere below /usr.
* add dc:title attribute to attr-ui-spec as window title
a dc:title attribute on attr-ui-spec should set the human readable
window title of evr-attr-ui
* define tasks for evr-attr-ui
the implementation will follow a model-view-controller approach. for
the beginning we allow two kinds of models. a single seed model and a
seed array model. the views must choose one kind of model they
support. the application is providing a model instance to the view
after creation.

initially we want to implement a form view. it will be used to show
the attributes for a single seed and later will be able to save user
entered attributes as a claim.

an example ui for creating a contact claim:
#+BEGIN_SRC xml
<attr-ui-spec xmlns="https://evr.ma300k.de/attr-ui/">
  <root>
    <!--
      we most likely want one (or more) roots… ther are most likely
      windows? so call them windows?

      maybe we should think also in a browser direction?
    -->
    <form>
      <claim-transformation>
        <!--
          contains an xslt to convert an attr claim as defined within
          https://evr.ma300k.de/claims/ into the user defined output
          claim.
        -->
      </claim-transformation>

      <text k="first-name">
        <required/>
      </text>
      <date k="birthday" year-optional="true"/>
      <seed-ref k="social-child-of" count="0..2">
        <seed-filter>class=contact</seed-filter>
      </seed-ref>
    </form>
  </root>
</attr-ui-spec>
#+END_SRC

another initial view should allow showing kanban like boards. a board
contains multiple columns which may contain multiple cards.

the card widget controls the visual representation of a single
card. the card widget must use a single seed model.

initially we want to provide a title-card widget which just shows a
seed attribute value. the box around the card is provided by the board
widget.

an example ui for showing a shopping list kanban board:
#+BEGIN_SRC xml
<attr-ui-spec xmlns="https://evr.ma300k.de/attr-ui/">
  <root>
    <board
        list-ordinal-key="ordinal"
        card-ordinal-key="shopping-list-ordinal"
      >
      <board-model query="class=board && board-id=offline-shopping"/>
      <list-model query="class=offline-shop"/>
      <card-model query="class=shopping-list-item && list={seed-ref}" />

      <card>
        <title-card k="title"></title-card>
      </card>
    </board>
  </root>
</attr-ui-spec>
#+END_SRC

an example ui for showing a task kanban board:
#+BEGIN_SRC xml
<attr-ui-spec xmlns="https://evr.ma300k.de/attr-ui/">
  <root>
    <board
        list-ordinal-key="ordinal"
        card-ordinal-key="todo-ordinal"
      >
      <board-model query="class=board && board-id=todo"/>
      <list-model query="class=todo-list && board-ref={seed-ref}"/>
      <card-model query="class=todo-task && task-state={title}" />

      <card>
        <title-card k="title"></title-card>
      </card>
    </board>
  </root>
</attr-ui-spec>
#+END_SRC

the *-model queries may reference the parent model's attributes using
{…} braces. the text within the braces is the attribute key. there is
one special attribute key "seed-ref" which references the seed-ref of
the parent model.

the board widget uses the set-ordinal claim defined in
https://evr.ma300k.de/attr-ui/ to apply an ordinal to a card or list.
* evr cli should validate put claim sets before upload
validate claims with [[https://relaxng.org/#validators][relax ng]] before putting them into
evr-glacier-storage.

validation rules must be stored with the attr-spec claim. that way the
index defines potential claims it should accept.

evr cli right now provides the sign-put command for uploading
claims. a caller must manually identify a claim by setting the flags
to 1. a new command put-claim must be added to evr cli. put-claim
should fetch the current active index from evr-attr-index, load the
rng grammar from the index's attr-spec and validade the put xml. after
successful validation the same steps as with sign-put must be
performed.

an example attr-spec might look like this:
#+BEGIN_SRC xml
<?xml version="1.0" encoding="UTF-8"?>
<claim-set
    xmlns="https://evr.ma300k.de/claims/"
    xmlns:dc="http://purl.org/dc/terms/"
    dc:created="1970-01-01T00:00:07.000000Z"
    >
  <attr-spec>
    <attr-def k="tag" type="str"/>
    <transformation type="xslt" blob="sha3-224-00000000000000000000000000000000000000000000000000000000"/>
    <schema type="rng">
        <grammar xmlns="http://relaxng.org/ns/structure/1.0">
            <!-- a rng grammar definition -->
        </grammar>
    </schema>
  </attr-spec>
</claim-set>
#+END_SRC

the doc/claims/attr-spec.xml example must be updatet to show an
example schema.

the put-claim command must set the evr cli flags argument implicitly
to 1. if the flags have been explicitly set to a value unequal to 1
the put-claim command must fail.

xml validation practically can't be executed in evr-glacier-storage
because the relax ng spec would need to be universal for at least all
past claims.
* add get-rnc command to evr cli
evr-attr-index in queried for the current active index. the attr-spec
is fetched for that index from evr-glacier-storage. the rng grammar is
extracted from the attr-spec if it exists. the rng grammar is
converted into a rnc grammar. the rng grammar is cached using the
index ref as file name. the rnc grammar is piped to stdout.

the rng to rnc conversion can probably be performed using
[[https://github.com/oleg-pavliv/emacs/blob/master/xsl/RngToRnc-1_4/RngToRncText.xsl][RngToRncText.xsl from oleg-pavliv]].
* evr emacs mode should load attr-spec rng validation
the minor mode evr-claim-set-mode must load the rng and load it for
the current buffer. this involves the following steps.

get the rnc via get-rnc into a buffer. parse the rnc from that buffer
and apply it to the current buffer.

the emacs lisp function rng-set-schema-file-1 shows how to load a rnc
schema and activate it for the current file. the function
rng-c-parse-file shows how to load rnc content into a buffer and parse
it.
* parallel evr-fs inode building
right now evr-fs builds the inodes sequentially one seed by another.

building inodes should be performed in parallel in n threads. n should
probably be something like 4 so we don't open too many connections
towards evr-attr-index.
* validate random blobs every 24 hours
so that basic sanity checks on servers with seldom reboots won't
happend seldom.

probably we should trigger the random blob validation via a command
sent to evr-glacier-storage. that way admins can set up a cron to
perform the check at a pleasant time. also checks can be triggered
manually on demand.
* evr-fs should recreate inodes on evr-attr-index current index change
right now only seed changes are applied to the inode set. if the index
ref changes the whole inode set must be rebuilt.
* document evr-fs in evr.texi
especially the seed-description xml format and the efs:file-set xml
format.
* add has key operator to attr query language
extend the attr query language to support searching for claims which
have a certain key.

not sure yet about the syntax:
#+BEGIN_SRC
tag=todo && some-key
tag=todo && some-key=*
has(some-key) // might clash with 'match functions' comming later
some-key!
#+END_SRC
* add not operator to attr query language
#+BEGIN_SRC
!tag=nsfw
!(tag=B || tag=C)
#+END_SRC

mapping the first example to sql would be quite easy because we could
do "c.seed not in (…)". but how to map the braces part i'm not sure
yet.
* support xsl:import with blob ref in xslt
evr uses xslt stylesheets when transforming claims in evr-attr-index
and when producing file metadata in evr-fs.

both places should support xsl:import statements so that stylesheets
can be structured. the xsl:import statements should be able to
reference blobs.
* glacier client must update flags in storage if necessary          :gcflgup:
right now the blob flags are untouched if the blob already
exists. this situation can actually happend if a user by accident
uploads a claim and misses the flags command line argument with evr
cli. if the user retries the upload with flags they will not be set.
* show in emacs if query is still running :emacs:
evr-attr-index commands like defun evr-attr-index-search-from-buffer
don't indicate wether they are still running or completed.

the user should be informed if the command completed. either by
showing a status like the emacs compile command or maybe a final line
in the buffer.
* evr sync should utilize the blob's last modified timestamp
right now evr sync walks through all blob refs and compares them
inbetween two evr-glacier-storage instances.

evr sync should have an optional state argument. when called with the
state argument evr cli should try to read a loast modified timestamp
from that state file. the sync should query only blob refs from the
two storages which appeared at or after the last modified timestamp.

this should speed up sync a lot for huge repositories. despite we will
loose some automatic restoration of blobs which got lost due to bit
flips in the buckets.
* migrate to partial evr-fs readdir buffer rebuilds
right now evr_fs_readdir in evr-fs.c builds the complete readdir
buffer only to report a slice of at an the end.

the off parameter should be used to communicate which inodes should
be read. probably the off parameter should be the directory child's
index from struct evr_fs_inode_dir.
* evr-fs integration test which restarts evr-glacier-storage
evr-fs should work just like before the restart. restart should maybe
occur while a file within evr-fs is open.
* improve query error messages if at least bison 3.6 is available
bison before 3.6 does not support "%define parse.error
detailed". that's why everarch right now uses the value "verbose".

the configure script should detect the bison version and use
"detailed" if at least bison 3.6 is available.
* open bucket file descriptor constant for uninitialized
glacier opens bucket files in a lazy way. the value for identifiying a
not yet opened bucket file should be a constant instead of just -1.
* add i18n support in attr query contains operator
right now sqlite is used for comparing values when using the attr
query contains (~) operator in a case insensitive way. the lower case
operation works only on ASCII characters. in order to get utf-8 lower
case conversion support the [[https://github.com/sqlite/sqlite/tree/master/ext/icu][sqlite ICU extension]] must be loaded.

test if this extension is part of the sqlite3 debian packaging. load
it gracefully. log info if it can't be loaded and continue.
* create bucket directory if not existing :bdircre:
* auto generate ssl cert and key if they don't exists
use some command like written in tls.txt
* add handling of too small bucket files
a bucket file which is smaller than the bucket file header of 4 bytes
should be recreated.
* add documentation on how to write attr-specs
** describe how attr is the central claim
** describe archive claim
** describe the seed and index-seed attributes
seed is provided before attr-factory calls and before each
transformation.

index-seed must be provided by transformation.
** describe how seed and index-seed must be handled in transformations
* reserve keywords in attr-query language
right now there are some keywords in attr-query language like for
example 'ref'. think about future keywords and reserve them so nobody
must rewrite queries in the future.
* ---- v0.1 boundary ----
everything above will be part of the first release of everarch. first
release means i will personally use it in production as mirror of my
perkeep stuff.
* evaluate http libraries for C
the evaluation should decide if the evr-web-server is implemented in C
, node.js or maybe deno.
* plan graph query approach
[[https://en.wikipedia.org/wiki/SPARQL][sparql]] queryability can be achieved via [[https://librdf.org/][librdf]] which stores data in
RDF. query output can be formatted with [[https://www.w3.org/TR/2013/REC-rdf-sparql-XMLres-20130321/][sparql xml results]].

we probably want to become a [[https://www.w3.org/wiki/SparqlEndpoints][SPARQL endpoint]]. despite this means we
need http support. SPARQL http access is described in [[https://www.w3.org/TR/2013/REC-sparql11-http-rdf-update-20130321/][SPARQL 1.1 Graph
Store HTTP Protocol]].
* report ref and some attributes specified by key in attr querries
the query might be something like: select title where tag=todo
* sort attr-query results by last modified timestamp
right now found claims are sorted by their creation date desc. further
sort orders should be able to be specified using a order by query
expression.

examples:
#+BEGIN_SRC
tag=todo order by last-modified
tag=todo order by last-modified desc
tag=todo order by last-modified asc
tag=todo order by created
tag=todo order by created desc
tag=todo order by created asc
#+END_SRC
* allow attr query args in quotes
#+BEGIN_SRC
'the key'='the value'
"the key"="the value"
#+END_SRC
* introduce evr-web-server
should bind to port 443 and respond some hello world as a demo.
* search seed claims endpoint for evr-web-server
GET /seeds?tag=todo
POST /seeds with query in post body?

responds found seed claims as JSON:

#+BEGIN_SRC
[
  {
    "ref": "sha3-224-…",
    "attr": {
      "tag": ["todo"]
    }
  }
]
#+END_SRC
* introduce evr-web-explorer
HTML/CSS/JS application which allows exploring seed claims. should use the evr-web-server API for retrieving 
* evr-web-explorer should show seed claims
query /seeds evr-web-server endpoint and show the seeds as some kind
of list.
* parallel evr-attr-index claim-set preparation
indexing a claim-set can be splitted into two phases. a first phase
which fetches the claim-set XML, then applies the attr factories and
XSLT stylesheet on it. then a second phase which persists the attr and
archive claims into the index.

the first phase should be executed in parallel.

the solution might involve a ring buffer which n slots. each slot
holds one to be prepared claim-set. the slots in the ring buffer have
the states queued and prepared. there are n threads which fetch the
next queued slot and prepare it.
* ---- v0.2 boundary ----
everything above will be part of the second major release of everarch.

the vision of the second release is: let's go web
* get rid of double _ in defines
as they are not intended for userspace. mentioned by pitrp.
* sort attr-query results by a certain attr key
right now found claims are sortable by their creation and last
modification date. with this task sorting by a certain attr should be
possible.

examples:
#+BEGIN_SRC
tag=todo order by title
tag=todo order by title desc
tag=todo order by title asc
#+END_SRC
* add match functions to attr query language
#+BEGIN_SRC
tag=todo && is_image(mime_type)
#+END_SRC

the open question is how to define what the match functions are
actually doing. for example which mime types are treated as
image. this should not be coded into everarch. it would be nice to be
able to define them somehow in blobs.
* make boolean and operator '&&' optional in attr query language
#+BEGIN_SRC
(tag=todo || tag=backlog) tag=howto
#+END_SRC
* evr-glacier-storage should notify systemd when ready
the systemd service type notify uses a notification approach provided
by libsystemd-daemon.so so the service can tell systemd it's
ready. this notifications should be performed after
evr-glacier-storage is listening on the socket for incomming
connections.

the configure.ac scripts should detect if systemd support is
available. maybe it the libsystemd-daemos.so or something is
present. if it is not found evr-glacier-storage must be compiled
without any systemd dependency.
* user PRI macros in format strings for integers
right now many places use for example %d or %ld for printing integers
with defined sizes like int64_t. the PRI* macros from [[https://cplusplus.com/reference/cinttypes/][inttypes.h]]
should be used instead. this should guarantee compatibility for other
platforms.
* use $XDG_CONFIG_HOME to lookup configuration directory
XDG_* is defined by the [[https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html][basedir-spec]].
* replace struct chunk_set with struct evr_llbuf_s
child_size could be 1 and block_child_count may be 1MB.

especially because struct chunk_set is not very well fitted for
growing because of the evr_chunk_set_max_chunks limitation.

there should also be a function for writing linked lists to a file
descriptor using writev.
** TODO struct evr_auth_token_cfg should use the linked list
** TODO struct evr_cert_cfg should use the linked list
* rename struct dynamic_array to evr_rabuf
dny-mem.h should provide one growable random access data structure.

struct dynamic_array should be renamed to hint the random access
usage. maybe evr_rabuf instead of dynamic_array.

pitrp also suggests to copy the XARRAY or X_ARRAY implementation from
the linux kernel.
* keep bucket file sizes below RLIMIT_FSIZE
bucket file sizes shold be below RLIMIT_FSIZE. see [[elisp:(manual-entry "setrlimit(2)")][setrlimit(2)]] for
retrieving RLIMIT_FSIZE and limit the bucket size regarding to
it. also the chunk size should not grow over the configured limit.
* switch to mmap/msync for writing bucket files
and measure the io performance compared to open and fsync.
* add quic support
in order to get faster connection building and encryption.

the most interesting quic library to use right now would be [[https://github.com/microsoft/msquic][msquic]]
because it depends just on OpenSSL. OpenSSL with downstream patches
unfortunately. there are [[https://www.openssl.org/blog/blog/2021/12/03/starting-the-quic-design/][plans by the OpenSSL team]] to add quic
support.
* switch to io_uring for network io
* use readv and writev in struct evr_file
right how read and write operations use via evr_file implement thea
read/write interface with one buffer.

struct evr_file should implement the readv and writev interface to
reduce the number of system calls needed.

the struct evr_file read and write functions should be removed. caller
code should be adjusted.
* introduce scripted transformations
attr specs should also support scripts which perform the claim
transformations instead of just xslt stylesheets.

a new transformation could look like this:

#+BEGIN_SRC xml
<attr-spec>
  <attr-def k="tag" type="str"/>
  <transformation type="bin" blob="sha3-224-00000000000000000000000000000000000000000000000000000000"/>
</attr-spec>
#+END_SRC

the transformation would point to an executable elf binary, shell or
python script.
* gracefully handle sqlite database is locked in evr-glacier-storage
sqlite's step function will exit with SQLITE_LOCKED if a table is
locked for more than 1sec (configured right now).

a SQLITE_LOCKED error should be indicated as 'resource temporary not
available' to the client.

i guess the basis for this task is no longer existent because we
switched to sqlite's WAL mode.
