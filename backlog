* open refs as seed search in evr.el
right now hitting enter on a claim ref will fetch the claim and show
in in another buffer. that behavior should be bound to the 'c'
key.

the enter key gets a new behavior. if it is a ref of the found claim
it should show the refs which are poining to that claim as seed.

if it is a ref which is the value of an attribute it should perform a
attr-query just for that ref in a new buffer. this will show all the
attributes of the ref.
* open ref as file in evr.el
whenever a ref is shown the key 'f' should follow the ref to the evr
file it's pointing to. the file must be shown in a new buffer.
* evr.el should provide a hook which runs after saving a file
that way it should be possible to store extra claims for the saved
file. for example a todo tag.
* an empty string attr-query should return any seeds
* attr-query searches should return the found claims ordered by date desc
the sort order should be by creation date of the seed in descending
order. sorting by last modified will require extra work to store the
latest modification timestamp. so it's down below in the backlog.
* log failed transformations and attr factory calls with claim-sets
failed xslt transformations and failed attr factory interactions
should be logged in the attr-index directory. the file name should be
the claim's ref with a .log extension. the log file should contain one
line which indicates what went wrong. then one empty line. then the
claim-set input or output which lead to an error.
* give claims a validity period
right now only claim attributes have a validity period. claims should
also have one.

the validity period starts with the creation timestamp of the seed
claim set.

the validity period ends for now never.

the attr-index db should be extended to hold the validity period.
* a new evr:archive claim should end the validity period of a claim
* add documentation on how to write attr-specs
** describe how attr is the central claim
** describe archive claim
** describe the seed and index-seed attributes
seed is provided before attr-factory calls and before each
transformation.

index-seed must be provided by transformation.
** describe how seed and index-seed must be handled in transformations
* plan backlog tasks for evr-glacier-storage sync
it should be possible to sync two evr-glacier-storage instances via
the evr cli.
* implement contains operator in attr queries
the contains operator should be the tilde. for example: title~peng.
* evr-attr-index must collect counts of seen claims
evr-attr-index must collect the element name and namespace of every
seen claims from the raw claim sets. the counts should be stored in
the index db.

there must be a command in the evr-attr-index search interface to
query the counts.

this feature should make it easier to gain an insight on the indexed
claims. mostly i want the feature to validate the attr-index works as
expected.

it also might help finding out which transformations should further be
added to the transformation xslt.
* count of seen claims should be queryable via attr-index cmd
* implement t in attr queries
tag=todo t=12345
tag=todo t=1970-01-01T00:00:07Z
* implement offset and limit in attr queries
tag=todo offset=0 limit=100
* add boolean or operator to attr query language
#+BEGIN_SRC
(tag=todo || tag=backlog) && tag=howto
#+END_SRC
* add braces to attr query language
#+BEGIN_SRC
(tag=todo || tag=backlog) && tag=howto
#+END_SRC
* add not operator to attr query language
#+BEGIN_SRC
!tag=nsfw
#+END_SRC
* make evr-glacier-storage port configurable
* make evr-attr-index port configurable
* store flags and blob size redundant in buckets
right now flags and blob size in the evr-glacier-storage are storend
once for every blob and without any checksum.

there should be either a checksum for the two fields or it should be
stored redundant. this should reduce the risk of breaking a whole
bucket if one blob in it has a bit error.
* migrate tcp sockets to tls
remove the unencrypted tcp ports and only allow tls secured tcp
connections.
* add authentication
think of some kind of authentication for the network sockets and
implement it.
* make accepted gpg keys for verfification configurable
right now the blob signature verification accepts all valid gpg
keys. we only want to accept certain gpg keys which are probably our
own.

also the gpg public keys should be stored in the storage as
blobs. that way they should never be lost. the configuration should
reference the gpg keys sha3-224 hashes.
* add claim-ref type in attr-spec's attr-def
add a new type which tells the attr-index to expect a reference to a
claim as value. attr-index should check if the value is parseable
using evr_parse_claim_ref(â€¦).
* reserve keywords in attr-query language
right now there are some keywords in attr-query language like for
example 'ref'. think about future keywords and reserve them so nobody
must rewrite queries in the future.
* ---- v0.1 boundary ----
everything above will be part of the first release of everarch. first
release means i will personally use it in production as mirror of my
perkeep stuff.
* sort attr-query results by last modified timestamp
right now found claims are sorted by their creation date desc. further
sort orders should be able to be specified using a order by query
expression.

examples:
#+BEGIN_SRC
tag=todo order by last-modified
tag=todo order by last-modified desc
tag=todo order by last-modified asc
tag=todo order by created
tag=todo order by created desc
tag=todo order by created asc
#+END_SRC
* sort attr-query results by a certain attr key
right now found claims are sortable by their creation and last
modification date. with this task sorting by a certain attr should be
possible.

examples:
#+BEGIN_SRC
tag=todo order by title
tag=todo order by title desc
tag=todo order by title asc
#+END_SRC
* add match functions to attr query language
#+BEGIN_SRC
tag=todo && is_image(mime_type)
#+END_SRC
* report ref and some attributes specified by key in attr querries
the query might be something like: select title where tag=todo
* make boolean and operator '&&' optional in attr query language
#+BEGIN_SRC
(tag=todo || tag=backlog) tag=howto
#+END_SRC
* follow claim-refs in emacs' evr-attr-index-results-mode
hitting enter on a claim ref should follow that reference. the claim
should be shown in a new buffer just like 'evr get-claim' prints it to
stdout.

the new buffer's major mode should be some sane mode for printing xml.
* gracefully handle sqlite database is locked in evr-glacier-storage
sqlite's step function will exit with SQLITE_LOCKED if a table is
locked for more than 1sec (configured right now).

a SQLITE_LOCKED error should be indicated as 'resource temporary not
available' to the client.
* gracefully handle sqlite database is locked in evr-attr-index
sqlite's step function will exit with SQLITE_LOCKED if a table is
locked for more than 1sec (configured right now).

a SQLITE_LOCKED error should be indicated as 'resource temporary not
available' to the client.
* add quic support
in order to get faster connection building and encryption.

the most interesting quic library to use right now would be [[https://github.com/microsoft/msquic][msquic]]
because it depends just on OpenSSL. OpenSSL with downstream patches
unfortunately. there are [[https://www.openssl.org/blog/blog/2021/12/03/starting-the-quic-design/][plans by the OpenSSL team]] to add quic
support.
* replace struct chunk_set with linked list
dny-mem.h should provide one growable random access data structure and
one growable linked list data structure.

especially struct dynamic_array is not very well fitted for growing
because of the evr_chunk_set_max_chunks limitation.

struct dynamic_array should be renamed to hint the random access
usage. maybe rabuf instead of dynamic_array and llbuf for chunk_set.

pitrp also suggests to copy the XARRAY or X_ARRAY implementation from
the linux kernel.

linked list chunk sizes maybe should be aligned with RLIMIT_FSIZE. see
[[elisp:(manual-entry "setrlimit(2)")][setrlimit(2)]] for retrieving RLIMIT_FSIZE and limit the chunk size
regarding to it. also the chunk size should not grow over 1MB.

there should also be a function for writing linked lists to a file
descriptor using writev.
* use writev instead of buf copying
writev can write mutliple buffers in one system call. this may reduce
the amout of memory being copied before a write call. there are
probably some places in glacier.c and the networking code which can
benefit from writev.
* introduce scripted transformations
attr specs should also support scripts which perform the claim
transformations instead of just xslt stylesheets.

a new transformation could look like this:

#+BEGIN_SRC xml
<attr-spec>
  <attr-def k="tag" type="str"/>
  <transformation type="bin" blob="sha3-224-00000000000000000000000000000000000000000000000000000000"/>
</attr-spec>
#+END_SRC

the transformation would point to an executable elf binary, shell or
python script.
* allow attr query args in quotes
#+BEGIN_SRC
'the key'='the value'
"the key"="the value"
#+END_SRC
* get rid of double _ in defines
as they are not intended for userspace. mentioned by pitrp.
* analyze and maybe replace own queues with lib io_uring
inter thread communitcation queues have been implemented in struct
evr_work_watch_ctx and struct evr_persister_ctx.

for the sake of using well tested code we should check migrating our
own queues to lib io_uring. mentioned by pitrp.
* implement an evr-glacier-storage blob put/get benchmark
should connect via network socket. send lots of blobs. request lots of
blobs. count blobs per second. maybe different blob sizes etc.
* create bucket directory if not existing :bdircre:
* repair out of sync bucket end pointer and file end offset :beprep:
the whole bucket should be scanned with validation of each key and
blob. if the file probably ends with one corrupt blob it should be
discarded.

it's important to be sensible about the discarded data at the end of
the file. maybe there should be an 'autorepair' flag in the
configuration.
