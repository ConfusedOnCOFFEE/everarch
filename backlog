* implement evr-attr-index-client.[hc]
the commands supported by the client library should be authenticate
and search.
* build seed-description XML
combines data about one seed in an xml element.

#+BEGIN_SRC xml
<seed-description>
  <claims>
    <!-- claims go here, may be implemented later -->
  </claims>
  <attr-index>
    <!-- provide only current attributes from attr-index -->
    <attr k="my-key" v="my-value"/>
  </attr-index>
</seed-description>
#+END_SRC

implement a formatter like the claim-set formatter in claims.h. see
the functions evr_init_claim_set, evr_append_file_claim,
evr_finalize_claim_set and evr_free_claim_set.
* implement parser for file-set claims
probably in claims.[hc]

an evr-fs file set may look like this:
#+BEGIN_SRC xml
<efs:file-set>
  <efs:file
    path="path/to/file.name"
    file-ref="sha3-224-123-0000"
    created="…"
    last-modified="…"
    />
</efs:file-set>
#+END_SRC

probably only functions for iterating over efs:file nodes are
necessary.
* implement evr-fs
evr-fs should be a user space file system which provides access to
files stored in everarch.

usage should be like:

#+BEGIN_SRC
$ evr-fs blob:sha3-224-dirs-files-xslt mount/point
#+END_SRC

the first argument is a reference to the xslt stylesheet used for
transforming a seed-description into a evr-fs file set.
* evr-fs should implement a blob cache
blobs should be cached so follow up reads of partial blobs are more
don't need refetching the blob from evr-glacier-storage.
* evr-fs should wath the evr-attr-index
evr-fs should watch the evr-attr-index and update it's file system
representation on evr-attr-index changes.
* reserve .evr in root directory within evr-fs
.evr should always be an empty directory. event if a efs:file mapps to
.evr. it should be like a reserved namespace for future interaction
with evr-fs during runtime.
* improve query error messages if at least bison 3.6 is available
bison before 3.6 does not support "%define parse.error
detailed". that's why everarch right now uses the value "verbose".

the configure script should detect the bison version and use
"detailed" if at least bison 3.6 is available.
* open bucket file descriptor constant for uninitialized
glacier opens bucket files in a lazy way. the value for identifiying a
not yet opened bucket file should be a constant instead of just -1.
* add i18n support in attr query contains operator
right now sqlite is used for comparing values when using the attr
query contains (~) operator in a case insensitive way. the lower case
operation works only on ASCII characters. in order to get utf-8 lower
case conversion support the [[https://github.com/sqlite/sqlite/tree/master/ext/icu][sqlite ICU extension]] must be loaded.

test if this extension is part of the sqlite3 debian packaging. load
it gracefully. log info if it can't be loaded and continue.
* add claim-ref type in attr-spec's attr-def
add a new type which tells the attr-index to expect a reference to a
claim as value. attr-index should check if the value is parseable
using evr_parse_claim_ref(…).
* make attr-index host and port configurabel in evr.el
right now it's hard coded in two places. first where the connection is
opened. second where the auth token is looked up.
* create bucket directory if not existing :bdircre:
* auto generate ssl cert and key if they don't exists
use some command like written in tls.txt
* add handling of too small bucket files
a bucket file which is smaller than the bucket file header of 4 bytes
should be recreated.
* add documentation on how to write attr-specs
** describe how attr is the central claim
** describe archive claim
** describe the seed and index-seed attributes
seed is provided before attr-factory calls and before each
transformation.

index-seed must be provided by transformation.
** describe how seed and index-seed must be handled in transformations
* reserve keywords in attr-query language
right now there are some keywords in attr-query language like for
example 'ref'. think about future keywords and reserve them so nobody
must rewrite queries in the future.
* ---- v0.1 boundary ----
everything above will be part of the first release of everarch. first
release means i will personally use it in production as mirror of my
perkeep stuff.
* evaluate http libraries for C
the evaluation should decide if the evr-web-server is implemented in C
, node.js or maybe deno.
* report ref and some attributes specified by key in attr querries
the query might be something like: select title where tag=todo
* sort attr-query results by last modified timestamp
right now found claims are sorted by their creation date desc. further
sort orders should be able to be specified using a order by query
expression.

examples:
#+BEGIN_SRC
tag=todo order by last-modified
tag=todo order by last-modified desc
tag=todo order by last-modified asc
tag=todo order by created
tag=todo order by created desc
tag=todo order by created asc
#+END_SRC
* allow attr query args in quotes
#+BEGIN_SRC
'the key'='the value'
"the key"="the value"
#+END_SRC
* introduce evr-web-server
should bind to port 443 and respond some hello world as a demo.
* search seed claims endpoint for evr-web-server
GET /seeds?tag=todo
POST /seeds with query in post body?

responds found seed claims as JSON:

#+BEGIN_SRC
[
  {
    "ref": "sha3-224-…",
    "attr": {
      "tag": ["todo"]
    }
  }
]
#+END_SRC
* introduce evr-web-explorer
HTML/CSS/JS application which allows exploring seed claims. should use the evr-web-server API for retrieving 
* evr-web-explorer should show seed claims
query /seeds evr-web-server endpoint and show the seeds as some kind
of list.
* parallel evr-attr-index claim-set preparation
indexing a claim-set can be splitted into two phases. a first phase
which fetches the claim-set XML, then applies the attr factories and
XSLT stylesheet on it. then a second phase which persists the attr and
archive claims into the index.

the first phase should be executed in parallel.

the solution might involve a ring buffer which n slots. each slot
holds one to be prepared claim-set. the slots in the ring buffer have
the states queued and prepared. there are n threads which fetch the
next queued slot and prepare it.
* ---- v0.2 boundary ----
everything above will be part of the second major release of everarch.

the vision of the second release is: let's go web
* get rid of double _ in defines
as they are not intended for userspace. mentioned by pitrp.
* add has key operator to attr query language
extend the attr query language to support searching for claims which
have a certain key.

not sure yet about the syntax:
#+BEGIN_SRC
tag=todo && some-key
tag=todo && some-key=*
#+END_SRC
* add not operator to attr query language
#+BEGIN_SRC
!tag=nsfw
!(tag=B || tag=C)
#+END_SRC

mapping the first example to sql would be quite easy because we could
do "c.seed not in (…)". but how to map the braces part i'm not sure
yet.
* sort attr-query results by a certain attr key
right now found claims are sortable by their creation and last
modification date. with this task sorting by a certain attr should be
possible.

examples:
#+BEGIN_SRC
tag=todo order by title
tag=todo order by title desc
tag=todo order by title asc
#+END_SRC
* add match functions to attr query language
#+BEGIN_SRC
tag=todo && is_image(mime_type)
#+END_SRC

the open question is how to define what the match functions are
actually doing. for example which mime types are treated as
image. this should not be coded into everarch. it would be nice to be
able to define them somehow in blobs.
* make boolean and operator '&&' optional in attr query language
#+BEGIN_SRC
(tag=todo || tag=backlog) tag=howto
#+END_SRC
* evr-glacier-storage should notify systemd when ready
the systemd service type notify uses a notification approach provided
by libsystemd-daemon.so so the service can tell systemd it's
ready. this notifications should be performed after
evr-glacier-storage is listening on the socket for incomming
connections.

the configure.ac scripts should detect if systemd support is
available. maybe it the libsystemd-daemos.so or something is
present. if it is not found evr-glacier-storage must be compiled
without any systemd dependency.
* user PRI macros in format strings for integers
right now many places use for example %d or %ld for printing integers
with defined sizes like int64_t. the PRI* macros from [[https://cplusplus.com/reference/cinttypes/][inttypes.h]]
should be used instead. this should guarantee compatibility for other
platforms.
* use $XDG_CONFIG_HOME to lookup configuration directory
XDG_* is defined by the [[https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html][basedir-spec]].
* replace struct chunk_set with struct evr_llbuf_s
child_size could be 1 and block_child_count may be 1MB.

especially because struct chunk_set is not very well fitted for
growing because of the evr_chunk_set_max_chunks limitation.

there should also be a function for writing linked lists to a file
descriptor using writev.
** TODO struct evr_auth_token_cfg should use the linked list
** TODO struct evr_cert_cfg should use the linked list
* rename struct dynamic_array to evr_rabuf
dny-mem.h should provide one growable random access data structure.

struct dynamic_array should be renamed to hint the random access
usage. maybe evr_rabuf instead of dynamic_array.

pitrp also suggests to copy the XARRAY or X_ARRAY implementation from
the linux kernel.
* keep bucket file sizes below RLIMIT_FSIZE
bucket file sizes shold be below RLIMIT_FSIZE. see [[elisp:(manual-entry "setrlimit(2)")][setrlimit(2)]] for
retrieving RLIMIT_FSIZE and limit the bucket size regarding to
it. also the chunk size should not grow over the configured limit.
* switch to mmap/msync for writing bucket files
and measure the io performance compared to open and fsync.
* add quic support
in order to get faster connection building and encryption.

the most interesting quic library to use right now would be [[https://github.com/microsoft/msquic][msquic]]
because it depends just on OpenSSL. OpenSSL with downstream patches
unfortunately. there are [[https://www.openssl.org/blog/blog/2021/12/03/starting-the-quic-design/][plans by the OpenSSL team]] to add quic
support.
* switch to io_uring for network io
* use readv and writev in struct evr_file
right how read and write operations use via evr_file implement thea
read/write interface with one buffer.

struct evr_file should implement the readv and writev interface to
reduce the number of system calls needed.

the struct evr_file read and write functions should be removed. caller
code should be adjusted.
* introduce scripted transformations
attr specs should also support scripts which perform the claim
transformations instead of just xslt stylesheets.

a new transformation could look like this:

#+BEGIN_SRC xml
<attr-spec>
  <attr-def k="tag" type="str"/>
  <transformation type="bin" blob="sha3-224-00000000000000000000000000000000000000000000000000000000"/>
</attr-spec>
#+END_SRC

the transformation would point to an executable elf binary, shell or
python script.
* gracefully handle sqlite database is locked in evr-glacier-storage
sqlite's step function will exit with SQLITE_LOCKED if a table is
locked for more than 1sec (configured right now).

a SQLITE_LOCKED error should be indicated as 'resource temporary not
available' to the client.

i guess the basis for this task is no longer existent because we
switched to sqlite's WAL mode.
