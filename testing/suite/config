# enable core dumps
ulimit -c unlimited

script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"

PATH="../../../src:${PATH}"

glacier_storage_port=2461
glacier_storage_bucket_dir=storage
glacier_storage_pid=
glacier_storage_cert_path="${script_dir}/../tls/glacier-cert.pem"
glacier_storage_auth_token='ac78ca737213680040b3c6420f04d6ede163e3a15fef022d281af87f31e25179'

secondary_glacier_storage_port=2561
secondary_glacier_storage_bucket_dir=secondary-storage
secondary_glacier_storage_pid=
secondary_glacier_storage_auth_token='ee3e9ad7a89ef1745f54f91689207d27d1b976a2791dca30ce74aef5c251e40f'

attr_index_port=2462
attr_index_state_dir=attr-index
attr_index_pid=
attr_index_cert_path="${script_dir}/../tls/attr-index-cert.pem"
attr_index_auth_token='7c0c40cb392ceeb42097988f21ed968f3590f25ae3deca8632e4a905cd340cbe'

if [ -e "${script_dir}/config.local" ]
then
    . "${script_dir}/config.local"
fi

allocate_ports() {
    ensure_port_available "${glacier_storage_port}"
    ensure_port_available "${secondary_glacier_storage_port}"
    ensure_port_available "${attr_index_port}"
}

write_evr_conf() {
    cat > evr.conf <<EOF
storage-port=${glacier_storage_port}
ssl-cert=localhost:${glacier_storage_port}:${glacier_storage_cert_path}
auth-token=localhost:${glacier_storage_port}:${glacier_storage_auth_token}
ssl-cert=localhost:${secondary_glacier_storage_port}:${glacier_storage_cert_path}
auth-token=localhost:${secondary_glacier_storage_port}:${secondary_glacier_storage_auth_token}
EOF
    append_accepted_gpg_keys >> evr.conf
    cat > evr-glacier-storage.conf <<EOF
port=${glacier_storage_port}
cert=${glacier_storage_cert_path}
key=${script_dir}/../tls/glacier-key.pem
auth-token=${glacier_storage_auth_token}
bucket-dir-path=${glacier_storage_bucket_dir}
EOF
    cat > evr-attr-index.conf <<EOF
state-dir-path=${attr_index_state_dir}
port=${attr_index_port}
storage-port=${glacier_storage_port}
storage-auth-token=${glacier_storage_auth_token}
cert=${attr_index_cert_path}
key=${script_dir}/../tls/attr-index-key.pem
auth-token=${attr_index_auth_token}
ssl-cert=localhost:${glacier_storage_port}:${glacier_storage_cert_path}
EOF
    append_accepted_gpg_keys >> evr-attr-index.conf
}

append_accepted_gpg_keys() {
    gpg --list-keys --with-colons | grep '^fpr:' | sed 's/fpr::*\(.*\):/\1/' | while read fpr
    do
        echo "accepted-gpg-key=${fpr}"
    done
}

start_glacier_storage() {
    rm -rf -- "${glacier_storage_bucket_dir}"
    mkdir -- "${glacier_storage_bucket_dir}"
    echo "Starting evr-glacier-storage…"
    evr-glacier-storage &
    glacier_storage_pid=$!
}

wait_for_glacier_storage() {
    wait_for_port "${glacier_storage_port}"
}

start_secondary_glacier_storage() {
    rm -rf -- "${secondary_glacier_storage_bucket_dir}"
    mkdir -- "${secondary_glacier_storage_bucket_dir}"
    echo "Starting secondary evr-glacier-storage…"
    evr-glacier-storage --port "${secondary_glacier_storage_port}" --auth-token "${secondary_glacier_storage_auth_token}" --bucket-dir-path "${secondary_glacier_storage_bucket_dir}" &
    secondary_glacier_storage_pid=$!
}

wait_for_secondary_glacier_storage() {
    wait_for_port "${secondary_glacier_storage_port}"
}

start_attr_index() {
    rm -rf -- "${attr_index_state_dir}"
    mkdir -- "${attr_index_state_dir}"
    echo "Starting evr-attr-index…"
    evr-attr-index &
    attr_index_pid=$!
}

wait_for_attr_index() {
    wait_for_port "${attr_index_port}"
    # TODO we should find a better way to wait until the index is
    # ready as sleeping for one second
    sleep 1
}

query_attr_index() {
    query="$1"
    socat ${socat_opts} "openssl:localhost:${attr_index_port},cafile=${attr_index_cert_path}" stdio <<EOF
a token ${attr_index_auth_token}
${query}
exit
EOF
}

wait_for_port() {
    port="$1"
    sleep 0.1
    while true
    do
        nc -q 0 localhost "${port}" < /dev/null && break
        echo "Waiting for port ${port}…"
        sleep 0.2
    done
}

ensure_port_available() {
    port="$1"
    nc -z localhost "${port}" && occupied=1 || occupied=0
    if [[ "${occupied}" == '1' ]]
    then
        echo "Port ${port} is not available for integration test. Aborting." >&2
        exit 1
    fi
}

# stop_everarch_servers is usually the target of a trap:
# trap stop_everarch_servers EXIT
stop_everarch_servers() {
    if [[ -n "${attr_index_pid}" ]]
    then
        kill -s sigint "${attr_index_pid}"
        wait "${attr_index_pid}" || true
        attr_index_pid=
    fi
    if [[ -n "${glacier_storage_pid}" ]]
    then
        kill -s sigint "${glacier_storage_pid}"
        wait "${glacier_storage_pid}" || true
        glacier_storage_pid=
        if [[ -e "${glacier_storage_bucket_dir}/lock" ]]
        then
            echo "${glacier_storage_bucket_dir}/lock still existing after storage quit" >&2
            exit 1
        fi
    fi
    if [[ -n "${secondary_glacier_storage_pid}" ]]
    then
        kill -s sigint "${secondary_glacier_storage_pid}"
        wait "${secondary_glacier_storage_pid}" || true
        secondary_glacier_storage_pid=
        if [[ -e "${secondary_glacier_storage_bucket_dir}/lock" ]]
        then
            echo "${secondary_glacier_storage_bucket_dir}/lock still existing after storage quit" >&2
            exit 1
        fi
    fi
}
