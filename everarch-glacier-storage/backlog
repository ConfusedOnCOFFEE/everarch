* migrate fprintf(stderr, …) to log_error(…)
* concurrent-glacier test which queues lots of tasks
one thread queues lots of tasks. blob should contain index of written
current blob. mock evr_glacier_append_blob tests if the index read
from the blob is incremented with each processed entry.
* add formatter and parser for human readable keys                    :hrkey:
keys should have a human readable form like sha224-deadbeef. there
should be a to-string formatter and a from-string parser.

the formatter and parser should be in a keys.h file which can easily
be moved into a central place if multiple modules will need it.
* command parser
network clients should be able to request and send blobs via commands.

functions for parsing commands from buffers and formatting commands
into buffers is necessary.

should be an extractable piece of code so we can reuse it in a future
client.
* open network socket, spawn threads, process commands
* implement an integration test / benchmark
should connect via network socket. send lots of blobs. request lots of
blobs. count blobs per second. maybe different blob sizes etc.
* align chunk size with RLIMIT_FSIZE
see [[elisp:(manual-entry "setrlimit(2)")][setrlimit(2)]] for retrieving RLIMIT_FSIZE and limit the chunk size
regarding to it. also the chunk size should not grow over 1MB.
* create bucket directory if not existing :bdircre:
* repair out of sync bucket end pointer and file end offset :beprep:
the whole bucket should be scanned with validation of each key and
blob. if the file probably ends with one corrupt blob it should be
discarded.

it's important to be sensible about the discarded data at the end of
the file. maybe there should be an 'autorepair' flag in the
configuration.
