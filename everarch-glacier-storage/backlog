* create ring buffer which is consumed by one glacier writer thread
the writer thread could use pthread_key_create to store the
evr_glacier_write_ctx and make sure it's destructed if the thread
crashes.
** ring buffer implementations
*** ringbuf MPSC
a possible ring buffer implementation is
https://github.com/rmind/ringbuf
*** ringbuffer SPMC
https://github.com/JohannesLorenz/ringbuffer
*** publib-dev
https://packages.debian.org/bullseye/publib-dev
sucht einen maintainer
*** libevent
https://libevent.org/
handles reading from file descriptors
*** ccl
https://github.com/jacob-navia/ccl
it seems like multi threaded writing must be forced by oneself
* add formatter and parser for human readable keys                    :hrkey:
keys should have a human readable form like sha224-deadbeef. there
should be a to-string formatter and a from-string parser.

the formatter and parser should be in a keys.h file which can easily
be moved into a central place if multiple modules will need it.
* align chunk size with RLIMIT_FSIZE
see [[elisp:(manual-entry "setrlimit(2)")][setrlimit(2)]] for retrieving RLIMIT_FSIZE and limit the chunk size
regarding to it. also the chunk size should not grow over 1MB.
* create bucket directory if not existing :bdircre:
* repair out of sync bucket end pointer and file end offset :beprep:
the whole bucket should be scanned with validation of each key and
blob. if the file probably ends with one corrupt blob it should be
discarded.

it's important to be sensible about the discarded data at the end of
the file. maybe there should be an 'autorepair' flag in the
configuration.
* TODO align queue memory to become lock free                          :qlck:
** alignment im kernel
wird über z.b. ____cacheline_aligned gesteuert. definiert in
include/linux/cache.h. verwendet ein gcc __attribute__. diese
attribute sind in der gcc info page im kapitel "6.33 Declaring
Attributes of Functions" erklärt.
** pitrp hints
pitrp gave me some hints on how to achieve this goal. i'm assuming the
solution must only work on linux with gcc.

-Wif-not-aligned  -- can help with debugging
-Wpacked-not-aligned  -- wenn du strukturen (denke mit #pragma pack) ausrichten willst

gcc dokumentation nachlesen was malloc() tut.  soweit ich weiss geben
sie dir immer machine architecture aligned memory -- ist aber nicht
ISO C spezifiziert

gcc hat alignment(), wenn ich mich nicht irre.

mmap ALIGN ... posix sysconf(_SC_PAGE_SIZE) => zwangsweise aligned,
weil pages immer aligned sind

pa_offset = offset & ~(sysconf(_SC_PAGE_SIZE) - 1);
